# 并发控制   

在单处理机系统中，事务并发运行其实不是真正的并发，这种方式称为交叉并发方法，在多处理机系统中，才是真正的并发运行，其方式称为同时并发方式。    

当多个用户并发的存取数据库时就会产生多个事务同时存取同一数据的情况，如果不进行合理的调度，就会破坏事务的一致性和数据库的一致性。      


## 并发操作带来的不一致情况    

并发控制带来的数据不一致性包括丢失修改，不可重复读，读脏数据。     

* 丢失修改     
    事务A先对数据库做了修改，但是事务B的提交破坏了事务A提交的结果，导致A的修改丢失。     
* 不可重复读     
    事务A先读取了数据，事务B执行了更新操作，使事务A无法再读取前一次的结果    

*  读脏数据     
    事务A先对数据库中某数据进行了修改，事务B读取了该数据，但是随后事务A撤销了上次的修改，这时数据库中的该数据恢复，而B得到的数据就是“脏”数据了。

上面三种方式都是由于破坏了事务的隔离性导致的，并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性。 

* 并发控制的技术     
    * 封锁   
    * 时间戳   
    * 乐观控制法    
    * 多版本并发控制       

## 封锁          

封锁包括两种锁，排他锁(X锁，写锁)和共享锁(S锁，读锁)         

* 两种锁的相容性规则：   

    * 排他锁    
        当事务A给数据R上了X锁后，其他任何事务就无法给R上任何类型的锁，必须等事务A释放了锁为止，这个过程中，只能由事务A对数据R进行修改和读取。   
    * 共享锁   
        当事务A给数据R上了S锁后，则事务A只能对数据R进行读取操作，而无法修改，这时其他事务都可以给数据R上S锁，但是不能上X锁，直到事务A释放了A上的S锁后，这就保证了其他事务也可以读R，但是不能修改。   

这两种锁互相组合还需要遵循一定的规则        


* 封锁协议    

    * 一级封锁协议        
        当事务A要对数据对象R进行修改时，必须先对R加X锁，直到事务A结束(事务结束是指commit后或者非正常结束rollback)时才解除封锁     
        
        一级封锁协议可以防止丢失修改，并保证事务A是可恢复的。    

    * 二级封锁协议    
        在一级封锁协议的基础上，当事务A要去读取数据对象R时，必须先对其上S锁，读取后即可释放S锁         

        二级封锁协议可以保证不会读到“脏”数据        

    * 三级封锁协议     
        在一级封锁协议的基础上，当事务A要去读取数据对象R时，必须先对其上S锁，直到事务结束后才可释放S锁。     

        三级封锁协议可以保证重复读数据       

    

    

        











