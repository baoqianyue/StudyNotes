# 真实感图形技术   

## 真实感图形生成流程    

构建模型 -> 投影变换 -> 消隐处理 -> 光照处理    

## 消隐算法   

消隐算法同时受视点(观察方向)和光照条件的影响    

* 绘制线框图时应该消除隐藏线,或用虚线表示不可见部分   
* 绘制真实感图形时应该消除隐藏面       

### 按照消隐空间分类    

* 对象空间消隐算法    

    物体空间就是对象所在的三维空间,以场景中的所有物体为处理单元,将三维物体直接放置在坐标系中,通过对每个物体的每一个面和其他物体(包括该物体本身)的面进行比较,确定哪些面是可见的    

    此类算法适用于线框图的绘制    
    如果空间中有`k`个物体,每个物体都需和它自身和其他`k-1`个物体进行比较,所以算法时间复杂度正比于`k^2`     

* 图像空间消隐算法   

    图形空间指的是当前物体显示时的屏幕坐标空间,先将三维物体投影到二维平面上,然后以窗口内部的每一个像素点为处理单元,确定在每一个像素点位置,场景中`k`个物体中哪一个距离视点最近,从而使用该物体的颜色作为该像素点的值      

    此类算法适用于消除隐藏面    
    如果空间中有`k`个物体,屏幕分辨率为`mxn`,则每一个像素点的确定都需要k个物体一一进行比较,所以算法时间复杂度正比于`m * n * k`     

### 深度缓冲器算法    

是一种简单的隐藏面消隐算法(图像空间消隐算法)      

* 数据结构   
    需要两个缓冲区   
    * 深度缓冲区    
        存放当前图像空间中每个可见像素的Z轴信息     
        `depthBuff(x, y)`     
    * 信息缓冲区   
        存放当前图像空间中每个可见像素的颜色属性信息      
        `frameBuff(x, y)`     

* 算法流程       

```
//首先初始化两个缓冲数组  
for (i = 0; i < xMax; i++)
    for(j = 0; j < yMax; j++)
    {
        depthBuff(i, j) = max; //先将深度缓冲中的所有深度都设置为设备允许的最大值  
        frameBuff(i, j) = backColor; //属性缓冲区中所有元素都设置为背景颜色   
    }

//处理场景中的每一个多边形(使用多边形扫描线的方式计算多边形面上每个点的深度值)   
for(每个多边形)  
{
    for(该多边形的每个像素(x,y))
    {
        计算当前像素的深度值z(x,y)
        if (z(x, y) < depthBuff(x, y))
            depthBuff(x, y) = z(x, y);
            frameBuff(x, y) = currentColor(x, y);
    }
}
```   

* 深度值的计算   
    使用扫描线从上到下,先对多边形的最高顶点开始递归的计算每个点的深度,可以使用增量的方式     

### 画家算法(深度排序算法)  

受画家作画时,由远及近绘制的启发,提出了**基于优先级队列的物体空间的消隐算法**      

该算法同时运用物体空间和图像空间    
排序操作既可以在像素空间,也可以在物体空间,而多边形面的扫描仅在图像空间完成     






