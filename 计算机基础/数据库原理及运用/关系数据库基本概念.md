# 关系数据库    

## 关系   
关系其实就是一张二维表
* 元组(tuple)
表中的一行称为一个元组     
* 属性(attribute)
表中的一列称为一个该关系的一个属性,每一列的列名称为属性名      
* 码(key)    
也称为码键，表中的某个属性组，它可以唯一确定一个元组   
* 域(domain)       
域是一类具有相同数据类型的值的集合，属性的取值范围来自某个域       
* 分量   
元组中的一个属性值    
* 关系模式      
对关系的描述，一般表示为:`关系名(属性1，属性2...属性n)`       

## 关系类型    
* 基本关系(通常称为基本表或基表)     
基本表是实际存在的表，他是实际存储数据的逻辑表示    
* 查询表    
查询表是查询结果对应的表    
* 视图表   
视图表示由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据    
* 基本关系的几条性质     
  * 列是同质的，即每一列中的分量取值都是来自同一个域    
  * 列的顺序无所谓，因为列顺序无关紧要，所以实际关系数据库中添加新属性时，永远都是插入到最后一行    
  * 任意两个元组的候选码都不能取相同的值    
  * 行的顺序无所谓   
  * 分量必须取原子值          

  
## 候选码和主码     
关系是笛卡儿积的有限子集，可以直接看成是一张二维表。      

关系中某一属性组的可以唯一的确定一个元组，那这个属性组就称为候选码，若一个关系中有多个候选码，则从中选定一个作为主码(primary key)    

## 基本的关系操作    
关系模型中常用的关系操作包括查询(query)操作和插入(insert)、删除(delete)、修改(update)操作两大部分。    

查询操作是关系操作中最主要的部分，查询操作又可以分为选择(selete)、投影(project)、连接(join)、除(divide)、并(except)、
交(intersection)、笛卡儿积等，其中选择、投影、并、差、笛卡儿积是5种基本操作，其他操作都可以由基本操作来定义和导出。    


## 关系的完整性      

完整性就是数据库内部的约束条件，这对于数据库正常运行也是有相当大的意义的      

### 实体完整性    
关系数据库中的每个元组应该是可区分的，是唯一的，保证元组的唯一性就要靠实体的完整性了。    

* 实体完整性规则    

若属性(一个或一组)A是基本关系R的主属性(主码中的属性)，则A不能取空值(null value),如果这个属性为空，就说明数据库中存在某个不可标识的实体，而我们说现实中的实体是可以区分的，它们有某种唯一的标识，如每个学生都是独立的个体，是不一样的。     

### 参照完整性    

参照完整性主要是针对于关系之间的引用情况，下面先看几个例子：    

有如下两个关系：   

`学生(*学号*，班级，姓名，性别，专业号，年龄)`    
`专业(*专业号*，专业名)`    

这里使用*包括起来的就是两个关系中的主码，在学生关系中有一个属性是专业号，这个属性恰好又是专业关系的主码，显然，学生关系中的"专业号"值必须是确实存在的，即专业关系中必须有该专业的记录，也就是说，学生关系中的某个属性的取值需要参照专业关系的属性取值，这也正是一种约束关系。     

当然这种参照关系不仅仅局限于两个关系之间，可以有多种有直接或间接引用情况的关系之间，同一关系内部属性也可能存在引用关系。    

`学生(*学号*，姓名，性别，专业号，年龄，班长)`关系中，学号属性是主码，班长属性代表该学生所在班级的班长的学号，它引用了本关系主码属性，即班长必须是确实存在的学生的学号。      


* 外码，参照与被参照关系    

设F是基本关系R的一个或一组属性，但不是R关系的码(该属性不包含在任何候选码中)，Ks是基本关系S的主码，如果F与Ks相对应，则称F是R的外码(foreign key)，并称基本关系R为参照关系(referencing relation)，基本关系S称为被参照关系或目标关系，关系R和S不一定是不同的关系。  

显然，参照关系R的外码F和目标关系S的主码F必须定义在同一个域上。   

  






